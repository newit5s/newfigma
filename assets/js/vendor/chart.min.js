/*!
 * Lightweight chart renderer bundled with Modern Restaurant Booking Manager.
 * Provides a minimal Chart.js compatible API for the built-in analytics views
 * without relying on external CDNs.
 */
(function (global) {
  'use strict';

  var DEFAULT_COLORS = [
    '#2563eb',
    '#0ea5e9',
    '#10b981',
    '#f97316',
    '#f43f5e'
  ];

  function isArray(value) {
    return Array.isArray ? Array.isArray(value) : Object.prototype.toString.call(value) === '[object Array]';
  }

  function toNumber(value) {
    var number = Number(value);
    if (typeof Number.isFinite === 'function') {
      return Number.isFinite(number) ? number : 0;
    }
    return isFinite(number) ? number : 0;
  }

  function pick(array, index, fallback) {
    if (!array || !array.length) {
      return fallback;
    }
    return array[index % array.length] || fallback;
  }

  function getColorAlpha(color, alpha) {
    if (typeof color !== 'string') {
      return 'rgba(37, 99, 235, ' + alpha + ')';
    }
    if (color.indexOf('rgba') === 0) {
      return color.replace(/rgba\(([^)]+),\s*[^,]+\)$/i, 'rgba($1, ' + alpha + ')');
    }
    if (color.indexOf('rgb') === 0) {
      return color.replace(/rgb\(([^)]+)\)$/i, 'rgba($1, ' + alpha + ')');
    }
    return color;
  }

  function ensureCanvasSize(chart) {
    var canvas = chart.canvas;
    if (!canvas) {
      return { width: 0, height: 0, ratio: 1 };
    }

    var ratio = (typeof window !== 'undefined' && window.devicePixelRatio) ? window.devicePixelRatio : 1;
    var cssWidth = Math.floor(canvas.clientWidth || canvas.width || Number(canvas.getAttribute('width')) || 600);
    var cssHeight = Math.floor(canvas.clientHeight || canvas.height || Number(canvas.getAttribute('height')) || 300);

    if (cssWidth <= 0) {
      cssWidth = 600;
    }
    if (cssHeight <= 0) {
      cssHeight = 300;
    }

    if (canvas.width !== cssWidth * ratio) {
      canvas.width = cssWidth * ratio;
    }
    if (canvas.height !== cssHeight * ratio) {
      canvas.height = cssHeight * ratio;
    }

    if (!canvas.style.width) {
      canvas.style.width = cssWidth + 'px';
    }
    if (!canvas.style.height) {
      canvas.style.height = cssHeight + 'px';
    }

    var ctx = chart.ctx;
    if (ctx && ctx.setTransform) {
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.scale(ratio, ratio);
    }

    return { width: cssWidth, height: cssHeight, ratio: ratio };
  }

  function ChartLite(ctx, config) {
    if (!(this instanceof ChartLite)) {
      return new ChartLite(ctx, config);
    }

    if (!ctx || !ctx.canvas) {
      throw new Error('Chart() requires a valid 2D rendering context.');
    }

    this.ctx = ctx;
    this.canvas = ctx.canvas;
    this.config = config || {};
    this.type = this.config.type || 'line';
    this.data = this.config.data || { labels: [], datasets: [] };
    this.options = this.config.options || {};

    this._resizeHandler = this.render.bind(this);

    if (typeof window !== 'undefined' && window.addEventListener) {
      window.addEventListener('resize', this._resizeHandler);
    }

    ChartLite._instances.push(this);

    this.render();
  }

  ChartLite._instances = [];
  ChartLite.version = 'lite-1.0.0';

  ChartLite.prototype.update = function update() {
    this.render();
  };

  ChartLite.prototype.render = function render() {
    if (!this.ctx) {
      return;
    }

    var dimensions = ensureCanvasSize(this);
    var width = dimensions.width;
    var height = dimensions.height;

    var ctx = this.ctx;
    ctx.clearRect(0, 0, width, height);

    if (!this.data) {
      return;
    }

    var labels = isArray(this.data.labels) ? this.data.labels : [];
    var datasets = isArray(this.data.datasets) ? this.data.datasets : [];
    if (!datasets.length) {
      return;
    }

    var padding = 48;
    var innerWidth = Math.max(width - padding * 2, 10);
    var innerHeight = Math.max(height - padding * 2, 10);

    var values = [];
    for (var i = 0; i < datasets.length; i++) {
      var dataset = datasets[i];
      if (!dataset) {
        continue;
      }
      var dataPoints = isArray(dataset.data) ? dataset.data : [];
      for (var j = 0; j < dataPoints.length; j++) {
        values.push(toNumber(dataPoints[j]));
      }
    }

    var minValue = values.length ? Math.min.apply(Math, values.concat(0)) : 0;
    var maxValue = values.length ? Math.max.apply(Math, values.concat(0)) : 0;
    if (minValue === maxValue) {
      maxValue = minValue + 1;
    }
    var range = maxValue - minValue;

    var gridLines = 4;
    ctx.lineWidth = 1;
    ctx.strokeStyle = 'rgba(148, 163, 184, 0.25)';
    for (var g = 0; g <= gridLines; g++) {
      var y = padding + (innerHeight / gridLines) * g;
      ctx.beginPath();
      ctx.moveTo(padding, y);
      ctx.lineTo(padding + innerWidth, y);
      ctx.stroke();
    }

    ctx.strokeStyle = 'rgba(100, 116, 139, 0.6)';
    ctx.lineWidth = 1.25;
    ctx.beginPath();
    ctx.moveTo(padding, padding);
    ctx.lineTo(padding, padding + innerHeight);
    ctx.lineTo(padding + innerWidth, padding + innerHeight);
    ctx.stroke();

    var tickCount = Math.min(labels.length, 6);
    ctx.fillStyle = 'rgba(148, 163, 184, 0.9)';
    ctx.font = '12px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    for (var t = 0; t < tickCount; t++) {
      var labelIndex = Math.round((labels.length - 1) * (t / Math.max(tickCount - 1, 1)));
      var labelX = padding + innerWidth * (labelIndex / Math.max(labels.length - 1, 1));
      ctx.fillText(String(labels[labelIndex] || ''), labelX, padding + innerHeight + 8);
    }

    ctx.textAlign = 'right';
    ctx.textBaseline = 'middle';
    for (var yTick = 0; yTick <= gridLines; yTick++) {
      var value = minValue + (range / gridLines) * yTick;
      var labelY = padding + innerHeight - (innerHeight / gridLines) * yTick;
      ctx.fillText(Math.round(value), padding - 8, labelY);
    }

    for (var d = 0; d < datasets.length; d++) {
      var current = datasets[d];
      if (!current) {
        continue;
      }

      var currentData = isArray(current.data) ? current.data : [];
      if (!currentData.length) {
        continue;
      }

      var color = current.borderColor || pick(DEFAULT_COLORS, d, DEFAULT_COLORS[0]);
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.lineJoin = 'round';
      ctx.lineCap = 'round';
      ctx.beginPath();

      for (var p = 0; p < currentData.length; p++) {
        var valuePoint = toNumber(currentData[p]);
        var x = padding + innerWidth * (p / Math.max(currentData.length - 1, 1));
        var yPoint = padding + innerHeight - ((valuePoint - minValue) / range) * innerHeight;
        if (p === 0) {
          ctx.moveTo(x, yPoint);
        } else {
          ctx.lineTo(x, yPoint);
        }
      }

      ctx.stroke();

      if (current.fill) {
        ctx.lineTo(padding + innerWidth, padding + innerHeight);
        ctx.lineTo(padding, padding + innerHeight);
        ctx.closePath();
        ctx.fillStyle = current.backgroundColor ? getColorAlpha(current.backgroundColor, 0.35) : getColorAlpha(color, 0.2);
        ctx.fill();
      }
    }
  };

  ChartLite.prototype.destroy = function destroy() {
    if (typeof window !== 'undefined' && window.removeEventListener && this._resizeHandler) {
      window.removeEventListener('resize', this._resizeHandler);
    }

    var index = ChartLite._instances.indexOf(this);
    if (index > -1) {
      ChartLite._instances.splice(index, 1);
    }

    this.ctx = null;
    this.canvas = null;
  };

  ChartLite.prototype.toBase64Image = function toBase64Image() {
    if (!this.canvas || typeof this.canvas.toDataURL !== 'function') {
      return '';
    }
    return this.canvas.toDataURL('image/png');
  };

  ChartLite.getChart = function getChart(canvas) {
    for (var i = 0; i < ChartLite._instances.length; i++) {
      if (ChartLite._instances[i].canvas === canvas) {
        return ChartLite._instances[i];
      }
    }
    return null;
  };

  global.Chart = global.Chart || ChartLite;
  global.ChartLite = ChartLite;
})(typeof window !== 'undefined' ? window : this);
